export const ONTOLOGY = {
  entities: [
    {
      id: "project",
      name: "Project",
      aliases: [
        "project",
        "project_name",
        "name_of_project",
        "name_of_ongoing_work",
        "name_of_project.",
      ],
    },
    {
      id: "state",
      name: "State/UT",
      aliases: ["state", "state-wise", "state_assigned"],
    },
    {
      id: "district",
      name: "District",
      aliases: ["district", "name_of_districts_invloved"],
    },
    {
      id: "segment",
      name: "Segment",
      aliases: ["segment_id"],
    },
    {
      id: "date",
      name: "Year/Time",
      aliases: ["year", "financial_year", "year-wise", "observation_year", "observation_month"],
    },
    {
      id: "corridor",
      name: "Corridor",
      aliases: ["length_in_km", "length_km", "stretch/_package_name", "district_target", "project_cost"],
    },
  ],
  relations: [
    {
      from: "project",
      to: "state",
      name: "located_in / implemented_in",
      rationale: "Project-level and state-level feeds carry explicit location keys.",
    },
    {
      from: "project",
      to: "district",
      name: "implemented_in_district",
      rationale: "Some project lists are district-scoped with project descriptors.",
    },
    {
      from: "segment",
      to: "state",
      name: "built_in",
      rationale: "Model segment rows inherit assigned state context.",
    },
    {
      from: "project",
      to: "date",
      name: "planned_or_reported_at",
      rationale: "Finance, construction and model rows carry year-level observations.",
    },
  ],
  provenance_rules: {
    official_measured: "Directly ingested from official government artifacts and APIs with manifest metadata.",
    proxy_derived: "OpenStreetMap / proxy geospatial or synthetic indicators used only as context.",
    model_output: "Scenario, risk and access projections generated by model passes, not policy facts.",
  },
};

const ENTITY_ALIASES = ONTOLOGY.entities.flatMap((e) =>
  e.aliases.map((alias) => ({ entityId: e.id, alias: alias.toLowerCase() }))
);

function hasColumn(entry, alias) {
  const manifest = entry?.manifest || {};
  const columns = Array.isArray(manifest?.columns) ? manifest.columns : [];
  const title = String(entry?.source?.title || entry?.source_id || "").toLowerCase();
  const datasetTitle = String(entry?.dataset_source || "").toLowerCase();
  const all = new Set([
    ...columns.map((c) => String(c).toLowerCase()),
    title,
    datasetTitle,
    String(entry?.source_id || "").toLowerCase(),
  ]);
  return all.has(alias.toLowerCase());
}

export function inferOntologyCoverage(catalog) {
  const entries = Object.values(catalog || {});
  const counts = {};
  ONTOLOGY.entities.forEach((entity) => {
    const matched = entries.filter((entry) => {
      return ENTITY_ALIASES.some((probe) => probe.entityId === entity.id && hasColumn(entry, probe.alias));
    });
    counts[entity.id] = matched.length;
  });

  const relationCoverage = ONTOLOGY.relations.map((relation) => {
    const fromCols = ENTITY_ALIASES.filter((alias) => alias.entityId === relation.from).map((x) => x.alias);
    const toCols = ENTITY_ALIASES.filter((alias) => alias.entityId === relation.to).map((x) => x.alias);
    const supporting = entries.filter((entry) => {
      return (
        ENTITY_ALIASES.some((probe) => probe.entityId === relation.from && hasColumn(entry, probe.alias)) &&
        ENTITY_ALIASES.some((probe) => probe.entityId === relation.to && hasColumn(entry, probe.alias))
      );
    });
    return {
      ...relation,
      evidence_count: supporting.length,
      supporting_sources: supporting.map((entry) => entry.source_id).filter(Boolean),
    };
  });

  return {
    entityCounts: counts,
    relationCoverage,
  };
}

